---
sidebar_position: 7
---

# Methods and Approaches

`ozone` can solve using a wide array of numerical methods and solution approaches. To specify a numerical method and solution approach use the first two arguments of the ODEProblem class instantiation.

For example
```py
from ozone.api import ODEProblem
ode_problem = ODEProblem(<numerical method string>, <solution approach string>, <number of timesteps>)
```

## Numerical Methods

**Numerical methods** are approximations that temporally discretize differential equations to approximate the solution. Both implicit and explicit Runge-Kutta methods are supported and are listed below:

- 'ForwardEuler'
- 'BackwardEuler'
- 'ExplicitMidpoint'
- 'ImplicitMidpoint'
- 'KuttaThirdOrder'
- 'RK4'
- 'RK6'
- 'RalstonsMethod'
- 'HeunsMethod'
- 'GaussLegendre2'
- 'GaussLegendre4'
- 'GaussLegendre6'
- 'Lobatto2'
- 'Lobatto4'
- 'RadauI3'
- 'RadauI5'
- 'RadauII3'
- 'RadauII5'
- 'Trapezoidal'
- 'AB1'
- 'AM1'
- 'BDF1'

## Solution Approaches

**Solution approaches** define how to solve the numerical methods listed above. There are three supported types:

- 'time-marching': Compute the state sequentially through timesteps.
- 'solver-based': Compute the state across timesteps in parallel.
- 'time-marching checkpointing': time-marching but memory usage is reduced with the added cost of slower computation time.
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[825],{3905:function(e,t,n){n.d(t,{Zo:function(){return o},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},o=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},_=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,o=p(e,["components","mdxType","originalType","parentName"]),_=d(n),m=r,f=_["".concat(l,".").concat(m)]||_[m]||u[m]||i;return n?a.createElement(f,s(s({ref:t},o),{},{components:n})):a.createElement(f,s({ref:t},o))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=_;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var d=2;d<i;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}_.displayName="MDXCreateElement"},8771:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return o},default:function(){return _}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],p={sidebar_position:1},l="General Example",d={unversionedId:"advanced/general-example",id:"advanced/general-example",title:"General Example",description:"This example uses almost all features.",source:"@site/docs/advanced/general-example.mdx",sourceDirName:"advanced",slug:"/advanced/general-example",permalink:"/ozone/docs/advanced/general-example",editUrl:"https://github.com/lsdolab/ozone/edit/main/website/docs/advanced/general-example.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Field and Profile Outputs",permalink:"/ozone/docs/advanced/field-profile-outputs"},next:{title:"NativeSystem ODE Functions",permalink:"/ozone/docs/advanced/nativsystem-odes"}},o=[],u={toc:o};function _(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"general-example"},"General Example"),(0,i.kt)("p",null,"This example uses almost all features."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"\nfrom scipy.linalg import block_diag\nfrom ozone.api import NativeSystem\nfrom scipy import sparse as sp\nimport matplotlib.pyplot as plt\nimport openmdao.api as om\nfrom ozone.api import ODEProblem, NativeSystem\nimport csdl\nimport csdl_om\nimport numpy as np\n\n\n# ODE problem CLASS\nclass ODEProblemTest(ODEProblem):\n    def setup(self):\n        # Define field outputs, profile outputs, states, parameters, times\n\n        # Outputs. coefficients for field outputs must be defined as an upstream variable\n        self.add_field_output('field_output_z', state_name='z', coefficients_name='coefficients')\n        self.add_field_output('field_output_y', state_name='y', coefficients_name='coefficients')\n\n        self.add_profile_output('profile_output_x')\n        self.add_profile_output('profile_output_z')\n\n        # If dynamic == True, The parameter must have shape = (self.num_times, ... shape of parameter @ every timestep ...)\n        # The ODE function will use the parameter value at timestep 't': parameter@ODEfunction[shape_p] = fullparameter[t, shape_p]\n        self.add_parameter('a', dynamic=True, shape=(self.num_times))\n        self.add_parameter('b', dynamic=True, shape=(self.num_times))\n        self.add_parameter('g', dynamic=True, shape=(self.num_times))\n        self.add_parameter('e', dynamic=True, shape=(self.num_times, 2, 2))\n        # If dynamic != True, it is a static parameter. i.e, the parameter used in the ODE is constant through time.\n        # Therefore, the shape does not depend on the number of timesteps\n        self.add_parameter('d')\n\n        # Inputs names correspond to respective upstream CSDL variables\n        self.add_state('y', 'dy_dt', initial_condition_name='y_0', output='y_integrated')\n        self.add_state('x', 'dx_dt', initial_condition_name='x_0')\n        self.add_state('z', 'dz_dt', initial_condition_name='z_0', shape=(2, 2), output='z_integrated')\n\n        self.add_times(step_vector='h')\n\n        # Define ODE and Profile Output systems (Either CSDL Model or Native System)\n\n        # ODE\n        self.set_ode_system(ODESystemNative)     # NATIVE comment one or the other\n        # self.set_ode_system(ODESystemCSDL)  # CSDL comment one or the other\n\n        # Profile\n        self.set_profile_system(POSystemNS)\n\n# The CSDL Model containing the ODE integrator\n\n\nclass RunModel(csdl.Model):\n    def initialize(self):\n        self.parameters.declare('num_timesteps')\n\n    def define(self):\n        num_times = self.parameters['num_timesteps']\n\n        h_stepsize = 0.05\n\n        # Create given inputs\n        # Coefficients for field output\n        self.create_input('coefficients', np.ones(num_times+1)/(num_times+1))\n        # Initial condition for state\n        self.create_input('y_0', 2.0)\n        self.create_input('x_0', 2.0)\n        self.create_input('z_0', np.array([[2.0, 1.0], [-1.0, -3.0]]))\n\n        # Create parameter for parameters a,b,g,d\n        a = np.zeros((num_times, ))  # dynamic parameter defined at every timestep\n        b = np.zeros((num_times, ))  # dynamic parameter defined at every timestep\n        g = np.zeros((num_times, ))  # dynamic parameter defined at every timestep\n        e = np.zeros((num_times, 2, 2))  # dynamic parameter defined at every timestep\n        d = 0.5  # static parameter\n        for t in range(num_times):\n            a[t] = 1.0 + t/num_times/5.0  # dynamic parameter defined at every timestep\n            b[t] = 0.5 + t/num_times/5.0  # dynamic parameter defined at every timestep\n            g[t] = 2.0 + t/num_times/5.0  # dynamic parameter defined at every timestep\n            e[t, :, :] = np.array([[0.3, 0.2], [0.1, -2.6]]) + t/num_times/5.0  # dynamic parameter defined at every timestep\n\n        # Add to csdl model which are fed into ODE Model\n        self.create_input('a', a)\n        self.create_input('b', b)\n        self.create_input('g', g)\n        self.create_input('d', d)\n        self.create_input('e', e)\n\n        # Timestep vector\n        h_vec = np.ones(num_times)*h_stepsize\n        self.create_input('h', h_vec)\n\n        # Create Model containing integrator\n        ODEProblem = ODEProblemTest('RK4', 'time-marching', num_times, display='default', visualization='none')\n        # ODEProblem = ODEProblemTest('RK4', 'time-marching checkpointing', num_times, display='default', visualization='none')\n        # ODEProblem = ODEProblemTest('RK4', 'solver-based', num_times, display='default', visualization='none')\n\n        self.add(ODEProblem.create_solver_model(), 'subgroup', ['*'])\n\n        foy = self.declare_variable('field_output_y')\n        pox = self.declare_variable('profile_output_x', shape=(num_times+1, ))\n        poz = self.declare_variable('profile_output_z', shape=(num_times+1, ))\n        y_int = self.declare_variable('y_integrated', shape=(num_times+1, ))\n        z_int = self.declare_variable('z_integrated', shape=(num_times+1, 2, 2))\n\n        self.register_output('total', pox[-1]+poz[-1]+foy[0]+y_int[-1])\n\n\nclass ODESystemNative(NativeSystem):\n    # Setup sets up variables. similar to ExplicitComponnent in OpenMDAO\n    def setup(self):\n        # Need to have ODE shapes similar as first example\n        n = self.num_nodes\n        self.add_input('y', shape=n)\n        self.add_input('x', shape=n)\n\n        self.add_output('dy_dt', shape=n)\n        self.add_output('dx_dt', shape=n)\n\n        self.add_input('a', shape=n)\n        self.add_input('b', shape=n)\n        self.add_input('g', shape=n)\n        self.add_input('d')\n        self.add_input('e', shape=(n, 2, 2))\n\n        self.add_input('z', shape=(n, 2, 2))\n        self.add_output('dz_dt', shape=(n, 2, 2))\n\n        self.declare_partial_properties('dy_dt', 'g', empty=True)\n        self.declare_partial_properties('dy_dt', 'd', empty=True)\n        self.declare_partial_properties('dy_dt', 'z', empty=True)\n        self.declare_partial_properties('dy_dt', 'e', empty=True)\n\n        self.declare_partial_properties('dx_dt', 'a', empty=True)\n        self.declare_partial_properties('dx_dt', 'b', empty=True)\n        self.declare_partial_properties('dx_dt', 'z', empty=True)\n        self.declare_partial_properties('dx_dt', 'e', empty=True)\n        self.declare_partial_properties('dx_dt', 'x', complex_step_directional=True)\n\n        self.declare_partial_properties('dz_dt', 'b', empty=True)\n        self.declare_partial_properties('dz_dt', 'g', empty=True)\n        self.declare_partial_properties('dz_dt', 'd', empty=True)\n        self.declare_partial_properties('dz_dt', 'x', sparse=True)\n\n        self.dzx = sp.csc_matrix(np.kron(np.eye(n), np.array([[0.5], [0.5], [0.5], [0.5]])))\n        # self.declare_partial_properties('dz_dt', 'y', empty=True)\n        # self.declare_partial_properties('dz_dt', 'a', empty=True)\n        # self.declare_partial_properties('dz_dt', 'x', empty=True)\n\n    # compute the ODE function. similar to ExplicitComponnent in OpenMDAO\n\n    def compute(self, inputs, outputs):\n        n = self.num_nodes\n        a = inputs['a']\n        b = inputs['b']\n        g = inputs['g']\n        d = inputs['d']\n\n        # Outputs\n        outputs['dy_dt'] = np.multiply(a, inputs['y']) - np.multiply(b, np.multiply(inputs['y'], inputs['x']))\n        outputs['dx_dt'] = np.multiply(g, np.multiply(inputs['y'], inputs['x'])) - d*inputs['x']\n\n        outputs['dz_dt'] = np.zeros((n, 2, 2))\n        # for key in inputs:\n        #     print(key, inputs[key])\n        for i in range(n):\n            outputs['dz_dt'][i, :, :] = -inputs['z'][i, :, :]/3.0+(inputs['y'][i]**2)/2.0+(inputs['a'][i])*inputs['e'][i, :, :]+inputs['x'][i]/2.0\n\n    def compute_partials(self, inputs, partials):\n        n = self.num_nodes\n        a = inputs['a']\n        b = inputs['b']\n        g = inputs['g']\n        d = inputs['d']\n\n        # The partials to compute.\n        partials['dy_dt']['y'] = np.diag(a - b*inputs['x'])\n        partials['dy_dt']['x'] = np.diag(- b*inputs['y'])\n        partials['dx_dt']['y'] = np.diag(g*inputs['x'])\n        # partials['dx_dt']['x'] = np.diag(g*inputs['y']-d)\n\n        partials['dy_dt']['a'] = np.diag(inputs['y'])\n        partials['dy_dt']['b'] = np.diag(-np.multiply(inputs['y'], inputs['x']))\n        partials['dx_dt']['d'] = np.array(-inputs['x'])\n        partials['dx_dt']['g'] = np.diag(np.multiply(inputs['y'], inputs['x']))\n\n        partials['dz_dt']['z'] = -np.eye(4*n)/3.0\n\n        list_block_y = []\n        list_block_a = []\n        list_block_e = []\n        for i in range(n):\n            list_block_y.append(np.array([[inputs['y'][i]], [inputs['y'][i]], [inputs['y'][i]], [inputs['y'][i]]]))\n            list_block_a.append(inputs['e'][i, :, :].reshape(4, 1))\n            list_block_e.append(np.eye(4)*inputs['a'][i])\n\n        partials['dz_dt']['y'] = block_diag(*list_block_y)\n        partials['dz_dt']['a'] = block_diag(*list_block_a)\n        partials['dz_dt']['e'] = block_diag(*list_block_e)\n        partials['dz_dt']['x'] = self.dzx\n        # partials['dz_dt']['x'] = np.kron(np.eye(n), np.array([[0.5], [0.5], [0.5], [0.5]]))\n\n        # print(partials['dz_dt']['y'])\n\n        # The structure of partials has the following for n = self.num_nodes =  4:\n        # d(dy_dt)/dy =\n        # [d(dy_dt1)/dy1  0               0               0            ]\n        # [0              d(dy_dt2)/dy2   0               0            ]\n        # [0              0               d(dy_dt2)/dy2   0            ]\n        # [0              0               0               d(dy_dt2)/dy2]\n        # Hence the diagonal\n\n\nclass ODESystemCSDL(csdl.Model):\n    # Setup sets up variables. similar to ExplicitComponnent in OpenMDAO\n    def initialize(self):\n        # Required every time for ODE systems or Profile Output systems\n        self.parameters.declare('num_nodes')\n\n    def define(self):\n        n = self.parameters['num_nodes']\n\n        y = self.declare_variable('y', shape=n)\n        x = self.declare_variable('x', shape=n)\n        a = self.declare_variable('a', shape=n)\n        b = self.declare_variable('b', shape=n)\n        g = self.declare_variable('g', shape=n)\n        d = self.declare_variable('d')\n        e = self.declare_variable('e', shape=(n, 2, 2))\n        z = self.declare_variable('z', shape=(n, 2, 2))\n\n        dy_dt = a*y - b*y*x\n        dx_dt = g*x*y-csdl.expand(d, n)*x\n\n        dz_dt = self.create_output('dz_dt', shape=(n, 2, 2))\n        for i in range(n):\n            temp_y = y[i]**2\n            temp_a = a[i]\n            temp_x = x[i]\n            dz_dt[i, :, :] = -z[i, :, :]/3.0+csdl.expand(temp_y, (1, 2, 2))/2.0 + csdl.expand(temp_a, (1, 2, 2))*e[i, :, :] + csdl.expand(temp_x, (1, 2, 2))/2.0\n\n        # self.register_output('dz_dt', dz_dt)\n        self.register_output('dy_dt', dy_dt)\n        self.register_output('dx_dt', dx_dt)\n\n\nclass POSystemNS(NativeSystem):\n\n    def setup(self):\n        # Need to have ODE shapes similar as first example\n        n = self.num_nodes\n        self.add_input('x', shape=n)\n        self.add_input('y', shape=n)\n        self.add_input('z', shape=(n, 2, 2))\n\n        self.add_output('profile_output_x', shape=(n))\n        self.add_output('profile_output_z', shape=(n))\n\n        c_z = np.arange(3, n*4+3, 4)\n        r_z = np.arange(0, n, 1)\n        v_z = np.ones(n)\n\n        rc_x = np.arange(0, n, 1)\n        v_x = np.ones(n)\n\n        self.declare_partial_properties('profile_output_z', 'z', rows=r_z, cols=c_z, vals=v_z)\n        self.declare_partial_properties('profile_output_z', 'x', empty=True)\n        self.declare_partial_properties('profile_output_z', 'y', empty=True)\n\n        self.declare_partial_properties('profile_output_x', 'x', rows=rc_x, cols=rc_x, vals=v_x)\n        self.declare_partial_properties('profile_output_x', 'z', empty=True)\n\n    def compute(self, inputs, outputs):\n        outputs['profile_output_z'] = inputs['z'][:, 1, 1].flatten()\n        outputs['profile_output_x'] = inputs['x'] + inputs['y']*inputs['y']\n\n    def compute_partials(self, inputs, partials):\n        partials['profile_output_x']['y'] = 2*np.diag(inputs['y'])\n\n\n# Simulator Object:\nnt = 30\nsim = csdl_om.Simulator(RunModel(num_timesteps=nt), mode='rev')\nsim.prob.run_model()\n# sim.visualize_implementation()\n\n# Checktotals\nprint(sim.prob['total'])\n# sim.prob.check_totals(of=['total'], wrt=['x_0', 'a', 'h'], compact_print=True)\n\nplt.show()\n\n")))}_.isMDXComponent=!0}}]);